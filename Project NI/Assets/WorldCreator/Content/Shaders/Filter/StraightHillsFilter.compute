#pragma kernel CSMain

StructuredBuffer<float> SrcBuffer;
RWStructuredBuffer<float> TmpBuffer;

static const float PI = 3.14159265358979323846f;

int StepSize;

float GeneralStrength;
float ErosionStrength;
float CurrentWidth;
float CurrentHeight;
float FilterDeltaValue;
float FilterDeltaValue2;
float ValleySmooth;
float Angle;
int Resolution;
int MinCount;
int MaxCount;
int Invert;

int GetSingleIndex(int y, int x)
{
  return y * Resolution + x;
}


[numthreads(32,32,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
  int bufferEnd = StepSize - 1;
  int x = id.x;
  int y = id.y;
  
  if(x > bufferEnd || y > bufferEnd)
    return;
  
  float currentValue = SrcBuffer[GetSingleIndex(y, x)];
 
  int xNeg = x == 0 ? x + 1 : x - 1;
  int xPos = x == bufferEnd ? x - 1 : x + 1;
  int yNeg = y == 0 ? y + 1 : y - 1;
  int yPos = y == bufferEnd ? y - 1 : y + 1;
  
  float arrayErosion[9];
  arrayErosion[0] = SrcBuffer[GetSingleIndex(yNeg, xNeg)];
  arrayErosion[1] = SrcBuffer[GetSingleIndex(yNeg, x)];
  arrayErosion[2] = SrcBuffer[GetSingleIndex(yNeg, xPos)];
  arrayErosion[3] = SrcBuffer[GetSingleIndex(y, xNeg)];
  arrayErosion[4] = SrcBuffer[GetSingleIndex(y, xPos)];
  arrayErosion[5] = SrcBuffer[GetSingleIndex(yPos, xNeg)];
  arrayErosion[6] = SrcBuffer[GetSingleIndex(yPos, x)];
  arrayErosion[7] = SrcBuffer[GetSingleIndex(yPos, xPos)];
  arrayErosion[8] = currentValue;

  float delta = 0.0f;
  float value = 0.0f;
  int counter = -1;

  float max = currentValue;
  float min = currentValue;
  
  
  if (Invert == 1)
  {
    bool changed;
    do
    {
      changed = false;
      [unroll]
      for(int i = 0 ; i < 8 ; i++)
      {
        if(arrayErosion[i] > arrayErosion[i + 1])
        {
          float tmp = arrayErosion[i];
          arrayErosion[i] = arrayErosion[i + 1];
          arrayErosion[i + 1] = tmp;
          changed = true;
        }
      }
    }while(changed);
  }
  else
  {
    bool changed;
    do
    {
      changed = false;
      [unroll]
      for(int i = 0 ; i < 8 ; i++)
      {
        if(arrayErosion[i] < arrayErosion[i + 1])
        {
          float tmp = arrayErosion[i];
          arrayErosion[i] = arrayErosion[i + 1];
          arrayErosion[i + 1] = tmp;
          changed = true;
        }
      }
    }while(changed);
  }
  
  for (int i = 0; i < 9; i++)
  {
    if (arrayErosion[i] <= currentValue)
      counter++;
  }
    
  float AngleA = (float)(atan(abs(arrayErosion[8] - arrayErosion[0]) * 
    CurrentHeight / (CurrentWidth / StepSize)) * 360.0f / PI / 2.0f);

  if (MinCount <= MaxCount)
  {
    if (counter >= MinCount && counter <= MaxCount)
    {
      value = FilterDeltaValue*sqrt((currentValue)*(ValleySmooth*currentValue))/
              2.0f + (arrayErosion[MaxCount] - arrayErosion[MinCount])*FilterDeltaValue2;
    }
    else
    {
      value = FilterDeltaValue*
              (currentValue/(9.0f - MinCount) + (arrayErosion[MaxCount]) -
               arrayErosion[MinCount])*FilterDeltaValue2;
    }

    if (AngleA > Angle)
      TmpBuffer[GetSingleIndex(y, x)]  = currentValue - value;
    else
      TmpBuffer[GetSingleIndex(y, x)]  = currentValue - value*value;
  }
  else
  {
    if (counter >= MinCount || counter <= MaxCount)
    {
      value = FilterDeltaValue*sqrt((currentValue)*(ValleySmooth*currentValue))/
              2.0f - (arrayErosion[MaxCount] - arrayErosion[MinCount])*FilterDeltaValue2;
    }
    else
    {
      value = FilterDeltaValue*
              (currentValue/(9.0f - MinCount) + (arrayErosion[MaxCount]) -
               arrayErosion[MinCount])*FilterDeltaValue2;
    }

    if (AngleA > Angle)
      TmpBuffer[GetSingleIndex(y, x)] = currentValue - value * value;
    else
      TmpBuffer[GetSingleIndex(y, x)] = currentValue - value;
  }
}
