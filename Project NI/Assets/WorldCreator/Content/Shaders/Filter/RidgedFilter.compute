#pragma kernel CSMain

StructuredBuffer<float> SrcBuffer;
RWStructuredBuffer<float> TmpBuffer;

static const float PI = 3.14159265358979323846f;

int StepSize;

float GeneralStrength;
float ErosionStrength;
float CurrentWidth;
float CurrentHeight;
float MinAngle;
float MaxAngle;
int Resolution;
int RidgeStrength;
int MinCount;
int MaxCount;

int Invert;

int GetSingleIndex(int y, int x)
{
  return y * Resolution + x;
}

[numthreads(32,32,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
  int bufferEnd = StepSize - 1;
  int x = id.x;
  int y = id.y;
  
  if(x > bufferEnd || y > bufferEnd)
    return;
  
  float currentValue = SrcBuffer[GetSingleIndex(y, x)];
 
  int xNeg = x == 0 ? x + 1 : x - 1;
  int xPos = x == bufferEnd ? x - 1 : x + 1;
  int yNeg = y == 0 ? y + 1 : y - 1;
  int yPos = y == bufferEnd ? y - 1 : y + 1;
  
  float arrayErosion[9];
  arrayErosion[0] = SrcBuffer[GetSingleIndex(yNeg, xNeg)];
  arrayErosion[1] = SrcBuffer[GetSingleIndex(yNeg, x)];
  arrayErosion[2] = SrcBuffer[GetSingleIndex(yNeg, xPos)];
  arrayErosion[3] = SrcBuffer[GetSingleIndex(y, xNeg)];
  arrayErosion[4] = SrcBuffer[GetSingleIndex(y, xPos)];
  arrayErosion[5] = SrcBuffer[GetSingleIndex(yPos, xNeg)];
  arrayErosion[6] = SrcBuffer[GetSingleIndex(yPos, x)];
  arrayErosion[7] = SrcBuffer[GetSingleIndex(yPos, xPos)];
  arrayErosion[8] = currentValue;

  float delta = 0.0f;
  float value = 0.0f;
  int counter = -1;
  float max = currentValue;
  float min = currentValue;

  for (int i = 0; i < 9; i++)
  {
    float erosion = arrayErosion[i];
    if (erosion <= currentValue)
      counter++;
    if (erosion > max)
      max = erosion;
    if (erosion < min)
      min = erosion;
  }

  if (Invert == 1)
  {
    float tmpInv = min;
    min = max;
    max = tmpInv;
  }

  float angleA = atan(abs(max - min) * CurrentHeight / (CurrentWidth / StepSize)) * 360.0f / PI / 2.0f;

  if (MinCount <= MaxCount)
  {
    if (MinAngle <= MaxAngle)
    {
      if (counter >= MinCount && counter <= MaxCount)
      {
        if (angleA >= MinAngle && angleA <= MaxAngle)
        {
          int maxY = -5, maxX = -6, minY = -7, minX = -8;
          for (int pY = -1; pY <= 1; pY++)
          {
            for (int pX = -1; pX <= 1; pX++)
            {
              if (pY == 0 && pX == 0)
                continue;

              if (y + pY > -1 && y + pY < StepSize && x + pX > -1 && x + pX < StepSize)
              {
                if (max == SrcBuffer[GetSingleIndex(y + pY, x + pX)])
                {
                  maxY = pY;
                  maxX = pX;
                }
                else if (min == SrcBuffer[GetSingleIndex(y + pY, x + pX)])
                {
                  minY = pY;
                  minX = pX;
                }
              }
            }
          }

          if (maxY == -minY && maxX == -minX)
          {
            delta = (currentValue - min) * GeneralStrength;
            value = MaxCount / 10.0f * ErosionStrength / 200.0f * delta;
          }
          else
            value = (min - max) / 8 * RidgeStrength / 100;
        }
      }
    }
    else
    {
      if (counter >= MinCount && counter <= MaxCount)
      {
        if (angleA >= MinAngle || angleA <= MaxAngle)
        {
          int maxY = -5, maxX = -6, minY = -7, minX = -8;
          for (int pY = -1; pY <= 1; pY++)
          {
            for (int pX = -1; pX <= 1; pX++)
            {
              if (pY == 0 && pX == 0)
                continue;

              if (y + pY > -1 && y + pY < StepSize && x + pX > -1 && x + pX < StepSize)
              {
                if (max == SrcBuffer[GetSingleIndex(y + pY, x + pX)])
                {
                  maxY = pY;
                  maxX = pX;
                }
                else if (min == SrcBuffer[GetSingleIndex(y + pY, x + pX)])
                {
                  minY = pY;
                  minX = pX;
                }
              }
            }
          }

          if (maxY == -minY && maxX == -minX)
          {
            delta = (currentValue - min) * GeneralStrength;
            value = MaxCount / 10.0f * ErosionStrength / 200.0f * delta;
          }
          else
            value = (min - max) / 8 * RidgeStrength / 100;
        }
      }
    }
  }
  else
  {
    if (MinAngle <= MaxAngle)
    {
      if (counter >= MinCount || counter <= MaxCount)
      {
        if (angleA >= MinAngle && angleA <= MaxAngle)
        {
          int maxY = -5, maxX = -6, minY = -7, minX = -8;
          for (int pY = -1; pY <= 1; pY++)
          {
            for (int pX = -1; pX <= 1; pX++)
            {
              if (pY == 0 && pX == 0)
                continue;

              if (y + pY > -1 && y + pY < StepSize && x + pX > -1 && x + pX < StepSize)
              {
                if (max == SrcBuffer[GetSingleIndex(y + pY, x + pX)])
                {
                  maxY = pY;
                  maxX = pX;
                }
                else if (min == SrcBuffer[GetSingleIndex(y + pY, x + pX)])
                {
                  minY = pY;
                  minX = pX;
                }
              }
            }
          }

          if (maxY == -minY && maxX == -minX)
          {
            delta = (currentValue - min) * GeneralStrength;
            value = MaxCount / 10.0f * ErosionStrength / 200.0f * delta;
          }
          else
            value = (min - max) / 8 * RidgeStrength / 100;
        }
      }
    }
    else
    {
      if (counter >= MinCount || counter <= MaxCount)
      {
        if (angleA >= MinAngle || angleA <= MaxAngle)
        {
          int maxY = -5, maxX = -6, minY = -7, minX = -8;
          for (int pY = -1; pY <= 1; pY++)
          {
            for (int pX = -1; pX <= 1; pX++)
            {
              if (pY == 0 && pX == 0)
                continue;

              if (y + pY > -1 && y + pY < StepSize && x + pX > -1 && x + pX < StepSize)
              {
                if (max == SrcBuffer[GetSingleIndex(y + pY, x + pX)])
                {
                  maxY = pY;
                  maxX = pX;
                }
                else if (min == SrcBuffer[GetSingleIndex(y + pY, x + pX)])
                {
                  minY = pY;
                  minX = pX;
                }
              }
            }
          }

          if (maxY == -minY && maxX == -minX)
          {
            delta = (currentValue - min) * GeneralStrength;
            value = MaxCount / 10.0f * ErosionStrength / 200.0f * delta;
          }
          else
            value = (min - max) / 8 * RidgeStrength / 100;
        }
      }
    }
  }

  TmpBuffer[GetSingleIndex(y, x)] = currentValue - value;
}
